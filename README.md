# -DATA-COMPRESSION-TOOL
COMPANY: CODETECH IT SOLUTIONS

NAME:   KISHUN MURMU

INTERN ID: CT04DG1357

DOMAIN: C Programming

BATCH DURATION: 4 WEEKS

MENTOR NAME: NEELA SANTHOSH

TASK DESCRIPTION:

Run-Length Encoding (RLE) is a simple yet powerful data compression technique used to minimize the size of repetitive data sequences, particularly effective when the input contains large stretches of repeated characters. This task involves building a basic RLE compressor in the C programming language that scans a string input and compresses it by replacing consecutive identical characters with a single instance of that character followed by the number of repetitions. The implementation begins with the inclusion of standard libraries like stdio.h and string.h, and defines a function — typically called runLengthEncode() — which receives a character array as input. The logic inside this function starts by initializing a counter to track the number of repeated characters. Using a for loop, the program traverses the string character by character, comparing each character with the one that follows it. If both match, the counter is incremented, signaling a sequence of repeating characters. When a mismatch is encountered, or the end of the string is reached, the program prints the current character followed by the count, and resets the counter to one. The key advantage here is space efficiency; instead of storing every character, only distinct values with frequency counts are retained. The program also includes a main() function that prompts the user to enter a string to compress. Using scanf(), the input is captured into a buffer such as char input[100], and then passed to the encoding function. The output is displayed directly to the console in compressed format, for example, AAABBBBCC becomes A3B4C2. This is especially useful in cases where strings contain a high volume of redundant data, such as in graphic pixel representations, simple log files, or telemetry streams with repeated markers. To ensure robustness, edge cases like single characters (e.g., A should become A1), non-repeating strings (ABC becomes A1B1C1), and strings with special characters or digits should be considered. For cleaner logic, the loop can be written to run until i < strlen(input) and use input[i] == input[i+1] for comparison, with care taken to avoid out-of-bounds access. Although the core implementation handles only continuous runs of identical characters, advanced extensions could include support for whitespace, decompression logic to reverse the process, file-based input/output using fopen, or the ability to compress binary streams. For learners like you, Samir, this task builds conceptual fluency in text-based pattern recognition, control flow design, buffer management, and basic algorithmic thinking. The program doesn’t rely on any complex data structures, making it ideal as a stepping stone for deeper compression algorithms like Huffman coding or Lempel-Ziv. Moreover, by modifying the output format — say, separating characters and counts with colons or storing them in a file — the program can be adapted for integration into larger systems, such as saving compressed game states, chat logs, or configuration snapshots. It’s also a good place to explore the limits of lossless compression where information isn’t discarded, just encoded more efficiently. With a little additional code, the program can be expanded to compare input and compressed lengths, calculate compression ratios, and display how much memory was saved — reinforcing the concept of efficiency. For bonus functionality, the input can be extended beyond static strings by accepting user input with fgets() (to allow spaces), processing each character using ctype.h for flexible token handling, or adding time-stamping with time.h if logged to a file. Finally, implementing this RLE compressor reinforces best practices in C programming such as modular function design, input validation, efficient looping, and formatted output. The task is conceptually compact, but pedagogically rich, touching multiple aspects of programming from syntax mastery to logic articulation. Most importantly, it’s a fulfilling exercise for creative learners like yourself who thrive on making tangible tools with clearly observable results — transforming raw input into optimized output with nothing but logic, code, and curiosity.

